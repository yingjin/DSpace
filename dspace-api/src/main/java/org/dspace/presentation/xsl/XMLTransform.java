package org.dspace.presentation.xsl;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamSource;

import org.apache.log4j.Logger;
import org.dspace.authorize.AuthorizeException;
import org.dspace.content.Bundle;
import org.dspace.content.Item;
import org.dspace.content.Bitstream;
import org.dspace.core.ConfigurationManager;
import org.dspace.core.Context;
import org.dspace.core.LogManager;
import org.jdom.Attribute;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.JDOMException;
import org.jdom.filter.ElementFilter;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.jdom.transform.JDOMResult;
import org.jdom.transform.JDOMSource;
import org.jdom.transform.XSLTransformException;

import org.dspace.content.service.ItemService;
import org.dspace.content.service.BundleService;
import org.dspace.content.service.BitstreamService;
import org.dspace.content.factory.ContentServiceFactory;

// Ying updated for DSpace 6 upgrade

public class XMLTransform
{
    /** log4j category */
    private static Logger log = Logger.getLogger(XMLTransform.class);
    
    /** only need one of these */
    static TransformerFactory tFactory = TransformerFactory.newInstance();
    
    private String name;
    private Transformer transformer = null;
    private File xslfile = null;
    private List<File> dependencies = null;
    private List<Long> dependencyModtimes = null;
    private long lastDependencyModtime = 0;
    private long lastDependencyCheck = 0;
    private String description;
    private Map<String, String> paramsAccepted;
    private List<String> schemasTransformed;
    private boolean transformBitstreamLinks;
    private boolean transformThumbnails;
    private boolean checkModtimes;
    
    ItemService itemService = ContentServiceFactory.getInstance().getItemService();
    BundleService bundleService = ContentServiceFactory.getInstance().getBundleService();
    BitstreamService  bitstreamService = ContentServiceFactory.getInstance().getBitstreamService();

    
    /**
     * Stores the configuration info, reads and parses the XSLT from disk, and creates the Transformer
     * @param name the name of this stylesheet configuration
     * @param filename the path to the main XSLT file to transform XML to HTML
     * @param dependencies a List of pathnames to other files that the transformation depends on,
     * i.e. other XSLT files imported or included by the main one
     * @param description a short description of what is generated by this transformer
     * @param paramsAccepted a Map with, as keys, the names of all parameters the XSLT takes, and as keys,
     * the default values to use if none is provided
     * @param schemasTransformed a List of official URLs for all XML schemas the XSLT can transform
     * @param transformBitstreamLinks whether to transform all HTML references in the generated output that point to
     * files with the same name as bitstreams in the Item containing the transformed source XML bitstream so that they
     * point to the DSpace URL for that bitstream
     * @param transformThumbnails whether to transform all HTML references in the generated output that point to
     * files with the same name as thumbnails in the Item containing the transformed source XML bitstream so that they
     * point to the DSpace URL for that thumbnail bitstream
     * @param reloadXSL whether to check for updated modification timestamps on the xsl file and its
     * dependencies and reload the stylesheet if any have been updated
     * @throws XSLTransformException
     */
    protected XMLTransform(String name, String filename, List<File> dependencies, String description,
                           Map<String, String> paramsAccepted, List<String> schemasTransformed, boolean transformBitstreamLinks,
                           boolean transformThumbnails, boolean reloadXSL)
    throws XSLTransformException
    {
        
        // store other data
        this.dependencies = dependencies;
        this.name = name;
        this.description = description;
        this.paramsAccepted = paramsAccepted;
        this.schemasTransformed = schemasTransformed;
        this.transformBitstreamLinks = transformBitstreamLinks;
        this.transformThumbnails = transformThumbnails;
        this.checkModtimes = reloadXSL;
        
        // store the xsl location
        xslfile = new File(filename);
        
        // set up modification timestamp checking
        this.dependencies.add(xslfile); // it depends on the xsl file, too.
        makeUpToDate();
        
        // if it isn't going to work, might as well know now.
        /* actually, be lazy here. uncomment if you want verfication up front.
         *getTransformer();
         */
    }
    
    /**
     * Check whether we have called updateModtimes() since any dependency files have changed,
     * and whether we care if we have.
     * @return true unless we haven't updated and should do so
     */
    private boolean isUpToDate()
    {
        // Can't be up-to-date if we haven't ever updated yet
        if (dependencyModtimes == null){
            return false;
        }
        
        if (checkModtimes) {
            
            // There's no need to check more than once a second. XSL files don't change on
            // disk that often. This shortcuts a double call of this method when first we
            // make sure this is up to date so we can discover that a cached generated
            // bitstream is out of date, then we make sure this is up to date again before
            // performing the transform needed to replace that stale cached bitstream.
            if (System.currentTimeMillis() - lastDependencyCheck < 1000)
            {
                return true;
            }
            
            // Check that each dependency file hasn't changed.
            for (int i=0; i<dependencies.size(); i++)
            {
                if (dependencies.get(i).lastModified() > dependencyModtimes.get(i).longValue())
                {
                    return false;
                }
            }
        }
        
        // either we're up to date, or we don't care about reloading the stylesheet when we aren't.
        return true;
    }
    
    /**
     * Updates the record of the last modification date for every file this XMLTransform depends on
     */
    private void updateModtimes()
    {
        dependencyModtimes = new ArrayList<Long>(dependencies.size());
        lastDependencyModtime = 0;
        for (File file : dependencies)
        {
            long modtime = file.lastModified();
            dependencyModtimes.add(new Long(modtime));
            if (modtime > lastDependencyModtime)
            {
                lastDependencyModtime = modtime;
            }
        }
        lastDependencyCheck = System.currentTimeMillis();
    }
    
    /**
     * Updates the dependency timestamp record to match the files on disk (if we are
     * caring about that). If we were not up to date, invalidates the Transformer until
     * it is regenerated.
     */
    private void makeUpToDate()
    {
        if (!isUpToDate())
        {
            transformer = null;
            updateModtimes();
        }
    }
    
    /**
     * Reports when the XMLTransform was last updated, checking the disk and
     * updating itself first if requested.
     * @param updateFirst whether to make sure everything is up-to-date before returning
     * a value. If this XMLTransform was initialized not to care about timestamps, it
     * still won't no matter how this parameter is set.
     * @return the last time the XMLTransform was updated, in the same formet used
     * by System.currentTimeMillis()
     */
    protected long lastModified(boolean updateFirst)
    {
        if (updateFirst)
        {
            makeUpToDate();
        }
        return lastDependencyModtime;
    }
    
    /**
     * Gets the Transformer configured with the proper stylesheet.
     * If it has not already been created or it is out of date, (re)creates it.
     * @return the javax.xml.transform.Transformer to use for xml processing
     */
    private Transformer getTransformer()
    {
        makeUpToDate();
        if (transformer == null)
        {
            try
            {
                transformer = tFactory.newTransformer(new StreamSource(xslfile));
            }
            catch (TransformerConfigurationException e)
            {
                transformer = null;
            }
        }
        return transformer;
    }
    
    /**
     * The name of this transformer, as specified in the config file.
     * @return the name as a String
     */
    public String getName()
    {
        return name;
    }
    
    /**
     * The description of the result of this transformer as specified in the config file.
     * @return the description as a String
     */
    public String getDescription()
    {
        return description;
    }
    
    /**
     * A Map with all the params accepted by the transformer as keys, and as values,
     * the default value of that parameter.
     * @return the Map of param names and default values
     */
    public Map<String, String> getParamsAccepted()
    {
        return paramsAccepted;
    }
    
    /**
     * Can this transformer work properly with XML documents of the given schema?
     * @param schema whether it will work
     * @return
     */
    public boolean isValidForSchema(String schema)
    {
        return schemasTransformed.contains(schema);
    }
    
    /**
     * Run the xsl on the input XML document using the given params
     * @param xml the JDOM Document to transform
     * @param params inputs to the xsl params
     * @return the transformed Document
     * @throws XSLTransformException
     */
    public Document transformXML(Document xml, Map<String, String> params) throws TransformerException
    {
        Transformer t = getTransformer();
        if (t != null)
        {
            // For each param the transform accepts, get the value passed in
            for (String paramName : paramsAccepted.keySet())
            {
                String paramValue = params.get(paramName);
                
                // If no value passed in, use the default
                if (paramValue == null)
                {
                    paramValue = paramsAccepted.get(paramName);
                }
                t.setParameter(paramName, paramValue);
            }
            
            // do transform
            JDOMSource source = new JDOMSource(xml);
            JDOMResult result = new JDOMResult();
            t.transform(source, result);
            return result.getDocument();
        }
        else
        {
            throw new TransformerException("XMLTransform: could not create transformer");
        }
    }
    
    /**
     * Return the bits generated by applying this transformation to the given source XML bitstream
     * @param context the DSpace context
     * @param item the Item containing the source Bitstream
     * @param sourceBitstream the XML bitstream to be transformed
     * @param params parameters to the transformation
     * @return an InputStream with the serialized transformed result HTML document
     * @throws AuthorizeException if adding or removing cache bitstreams fails
     * @throws SQLException if adding or removing cache bitstreams fails
     * @throws IOException if adding or removing cache bitstreams fails
     * @throws JDOMException if the source bitstream could not be parsed
     * @throws TransformerException if the XSL transform failed
     */
    public InputStream transformedResult(Context context, Item item, Bitstream sourceBitstream,
                                         Map<String, String> params)
    throws AuthorizeException, SQLException, IOException, JDOMException, TransformerException
    {
        log.info(LogManager.getHeader(context, "transform_bitstream",
                                      "bitstream_id=" + sourceBitstream.getID() + " using xsl=" + name));
        
        // parse in the xml from the source bitstream
        Document xmlfile;
        Document htmlfile;
        SAXBuilder builder = new SAXBuilder();
        xmlfile = builder.build(bitstreamService.retrieve(context, sourceBitstream));
        
        // run the XSL transformation
        htmlfile = transformXML(xmlfile, params);
        
        // Store commonly used info for next step
        String hostname = ConfigurationManager.getProperty("dspace.hostname");
        String jspurl = ConfigurationManager.getProperty("dspace.url");
        String handle = item.getHandle();
        
        // Transform links to bitstreams
        if (transformBitstreamLinks)
        {
            Map<String, String> links = new HashMap<String,String>(700);
            for (Bitstream bitstream : getBitstreamsInBundle(context, item, "ORIGINAL")) {
                links.put(bitstream.getName(), jspurl+"/bitstream/"
                          +handle+'/'
                          +String.valueOf(bitstream.getSequenceID())+'/'
                          +bitstream.getName());
            }
            // replace all matching "a href=" values with links to the BitstreamServlet for individual display
            replaceMatchingAttributes(htmlfile, "a", "href", links);
        }
        
        // Transform inline images that reference thumbnails
        if (transformThumbnails)
        {
            Map<String, String> links = new HashMap<String,String>(700);
            for (Bitstream bitstream : getBitstreamsInBundle(context, item, "THUMBNAIL")) {
                links.put(bitstream.getName(), jspurl+"/retrieve/"
                          +String.valueOf(bitstream.getID())
                          +"/"+bitstream.getName());
            }
            
            // If using thumbnails served directly by Apache, those override.
            String thumbnailDir = ConfigurationManager.getProperty("apache.thumbnaildir");
            String thumbnailurl = ConfigurationManager.getProperty("apache.thumbnailurl");
            if (thumbnailDir != null && thumbnailurl != null)
            {
                File d = new java.io.File(thumbnailDir+'/'+handle);
                if (d != null && d.isDirectory())
                {
                    // Find all .jpg and .gif files in thumbnaildir
                    String[] files = d.list(new java.io.FilenameFilter()
                                            {
                        public boolean accept(File dir, String file)
                        {
                            return file.endsWith(".jpg") || file.endsWith(".gif");
                        }
                    });
                    for (String filename : Arrays.asList(files))
                    {
                        links.put(filename, "http://"+hostname+'/'+thumbnailurl+'/'+handle+'/'+filename);
                    }
                }
            }
            
            // replace all matching "img src=" values with links to the RetrieveServlet for faster display
            replaceMatchingAttributes(htmlfile, "img", "src", links);
        }
        
        // serialize html output to a buffer
        XMLOutputter outputter = new XMLOutputter();
        ByteArrayOutputStream bitsOut = new ByteArrayOutputStream();
        outputter.output(htmlfile, bitsOut);
        return new ByteArrayInputStream(bitsOut.toByteArray());
    }
    
    // *******************   Link replacement   ********************************
    
    
    private List<Bitstream> getBitstreamsInBundle(Context context, Item item, String bundleName) {
        // get named bundles
        try{
            List<Bundle> bundles = itemService.getBundles(item, bundleName);
            Bundle bundle = bundles.get(0);
        
            // get all bitstreams in each named bundle
            List<Bitstream> bitstreams = bundle.getBitstreams();
            return bitstreams;
        }catch(java.sql.SQLException e){
            return null;
        }
        
    }
    
    /**
     * Find all the matching attributes in the XML doc and, if their value is a key in the provided map, replace it
     * with the mapped value.
     * @param doc the XML document to alter
     * @param elementName alter attributes of elements with this name
     * @param attributeName alter values of attributes with this name within matching elements
     * @param map alter values of matching attributes if they equal a key in this map. If the attribute value
     * contains any / characters, only text after the last / will be matched, but the whole value will be replaced.
     */
    private void replaceMatchingAttributes(Document doc, String elementName, String attributeName,
                                           Map<String, String> map)
    {
        // get all elements with the given name
        Iterator elements = doc.getDescendants(new ElementFilter(elementName));
        while (elements.hasNext())
        {
            // get the attribute from the matching element
            Attribute attribute = ((Element)elements.next()).getAttribute(attributeName);
            if (attribute != null) {
                
                // Now remove any prefix, ie, make images/foo.jpg into just foo.jpg
                String value = attribute.getValue();
                value = value.substring(value.lastIndexOf('/') + 1);
                
                // If it's in the map, replace the value.
                String newValue = map.get(value);
                if (newValue != null)
                {
                    attribute.setValue(newValue);
                }
            }
        }
    }
    
}
